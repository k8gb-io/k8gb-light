package controllers

/*
Copyright 2022 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"context"
	"fmt"
	"testing"
	"time"

	"cloud.example.com/annotation-operator/controllers/reconciliation"

	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime/schema"

	"cloud.example.com/annotation-operator/controllers/logging"

	"cloud.example.com/annotation-operator/controllers/providers/metrics"

	"github.com/stretchr/testify/assert"
	controllerruntime "sigs.k8s.io/controller-runtime"

	"cloud.example.com/annotation-operator/controllers/depresolver"
	"cloud.example.com/annotation-operator/controllers/mocks"
	"cloud.example.com/annotation-operator/controllers/utils"
	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/require"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"
)

func TestReconcileRequest(t *testing.T) {
	// arrange
	const (
		reconcileRequeue = 30 * time.Second
		ingressName      = "ing"
	)
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	tests := []struct {
		Name    string
		Request reconcile.Request
		Result  controllerruntime.Result
	}{
		{
			Name:    "Request Empty",
			Request: reconcile.Request{NamespacedName: types.NamespacedName{Namespace: "", Name: ""}},
			Result:  reconcile.Result{Requeue: false, RequeueAfter: reconcileRequeue},
		},
		{
			Name:    "Request Namespace",
			Request: reconcile.Request{NamespacedName: types.NamespacedName{Namespace: "demo", Name: ""}},
			Result:  reconcile.Result{Requeue: false, RequeueAfter: reconcileRequeue},
		},
		{
			Name:    "Request Name",
			Request: reconcile.Request{NamespacedName: types.NamespacedName{Namespace: "", Name: ingressName}},
			Result:  reconcile.Result{Requeue: false, RequeueAfter: reconcileRequeue},
		},
		{
			Name:    "Ingress Error",
			Request: reconcile.Request{NamespacedName: types.NamespacedName{Namespace: "error", Name: ingressName}},
			Result:  reconcile.Result{Requeue: false, RequeueAfter: reconcileRequeue},
		},
		{
			Name:    "Ingress NotFound",
			Request: reconcile.Request{NamespacedName: types.NamespacedName{Namespace: "notFound", Name: ingressName}},
			Result:  reconcile.Result{Requeue: false, RequeueAfter: 0},
		},
		{
			Name:    "Ingress Found Without Annotation",
			Request: reconcile.Request{NamespacedName: types.NamespacedName{Namespace: "foundNoAnnotation", Name: ingressName}},
			Result:  reconcile.Result{Requeue: false, RequeueAfter: 0},
		},
	}

	cl := fakeClient(ctrl)
	cl.Config.ReconcileRequeueSeconds = int(reconcileRequeue.Seconds())
	cl.Client.(*mocks.MockClient).EXPECT().Get(gomock.Any(), types.NamespacedName{Namespace: "notFound", Name: ingressName}, gomock.Any()).
		Return(errors.NewNotFound(schema.GroupResource{}, ingressName)).AnyTimes()
	cl.Client.(*mocks.MockClient).EXPECT().Get(gomock.Any(), types.NamespacedName{Namespace: "error", Name: ingressName}, gomock.Any()).
		Return(fmt.Errorf("random error")).AnyTimes()
	cl.Client.(*mocks.MockClient).EXPECT().Get(gomock.Any(), types.NamespacedName{Namespace: "foundNoAnnotation", Name: ingressName}, gomock.Any()).
		Return(nil).AnyTimes()

	// act
	// assert
	for _, test := range tests {
		t.Run(test.Name, func(t *testing.T) {
			result, err := cl.Reconcile(context.TODO(), test.Request)
			assert.Equal(t, test.Result, result)
			require.NoError(t, err)
		})
	}
}

func TestFinalizerInReconciliation(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	//m := fakeMapper(ctrl)

	//m.handleFinalizer()
}

func TestHandleFinalizer(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	// arrange
	var ferr = fmt.Errorf("finalizer err")
	var tests = []struct {
		Name           string
		ExpectedResult reconciliation.MapperResult
		SetMocks       func(*mocks.MockMapper)
	}{
		{
			Name:           "Inject Finalizer",
			ExpectedResult: reconciliation.MapperFinalizerInstalled,
			SetMocks: func(c *mocks.MockMapper) {
				c.EXPECT().TryInjectFinalizer(gomock.Any()).Return(reconciliation.MapperFinalizerInstalled, nil).Times(1)
			},
		},
		{
			Name:           "Inject Finalizer Error",
			ExpectedResult: reconciliation.MapperResultError,
			SetMocks: func(c *mocks.MockMapper) {
				c.EXPECT().TryInjectFinalizer(gomock.Any()).Return(reconciliation.MapperResultError, ferr).Times(1)
			},
		},
		{
			Name:           "Remove Finalizer",
			ExpectedResult: reconciliation.MapperFinalizerRemoved,
			SetMocks: func(c *mocks.MockMapper) {
				c.EXPECT().TryInjectFinalizer(gomock.Any()).Return(reconciliation.MapperFinalizerSkipped, nil).Times(1)
				c.EXPECT().TryRemoveFinalizer(gomock.Any(), gomock.Any()).Return(reconciliation.MapperFinalizerRemoved, nil).Times(1)
			},
		},
		{
			Name:           "Remove Finalizer Error",
			ExpectedResult: reconciliation.MapperResultError,
			SetMocks: func(c *mocks.MockMapper) {
				c.EXPECT().TryInjectFinalizer(gomock.Any()).Return(reconciliation.MapperFinalizerSkipped, nil).Times(1)
				c.EXPECT().TryRemoveFinalizer(gomock.Any(), gomock.Any()).Return(reconciliation.MapperResultError, ferr).Times(1)
			},
		},
		{
			Name:           "Finalizer Skipped",
			ExpectedResult: reconciliation.MapperFinalizerSkipped,
			SetMocks: func(c *mocks.MockMapper) {
				c.EXPECT().TryInjectFinalizer(gomock.Any()).Return(reconciliation.MapperFinalizerSkipped, nil).Times(1)
				c.EXPECT().TryRemoveFinalizer(gomock.Any(), gomock.Any()).Return(reconciliation.MapperFinalizerSkipped, ferr).Times(1)
			},
		},
	}

	// act
	// assert
	for _, test := range tests {
		t.Run(test.Name, func(t *testing.T) {
			r := fakeMapper(ctrl)
			test.SetMocks(r.IngressMapper.(*mocks.MockMapper))
			result, err := r.handleFinalizer(nil)
			assert.Equal(t, test.ExpectedResult, result)
			if result == reconciliation.MapperResultError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

// if you want to mock client use fakeClient
func fakeClient(ctrl *gomock.Controller) *AnnoReconciler {
	r := fakeMapper(ctrl)
	r.IngressMapper = reconciliation.NewIngressMapper(r.Client)
	return r
}

// if you want to mock mapper use fakeMapper
func fakeMapper(ctrl *gomock.Controller) *AnnoReconciler {
	c := mocks.NewMockClient(ctrl)
	r := mocks.NewMockGslbResolver(ctrl)
	p := mocks.NewMockProvider(ctrl)
	tr := mocks.NewMockTracer(ctrl)
	trsp := mocks.NewMockSpan(ctrl)
	m := mocks.NewMockMapper(ctrl)

	config := &depresolver.Config{
		ReconcileRequeueSeconds: 30,
	}
	reconciler := &AnnoReconciler{
		Scheme:           runtime.NewScheme(),
		Client:           c,
		DepResolver:      r,
		DNSProvider:      p,
		Config:           config,
		IngressMapper:    m,
		Tracer:           tr,
		ReconcilerResult: utils.NewReconcileResultHandler(config.ReconcileRequeueSeconds),
		Log:              logging.Logger(),
		Metrics:          metrics.Metrics(),
	}
	trsp.EXPECT().End(gomock.Any()).Return().AnyTimes()
	tr.EXPECT().Start(gomock.Any(), gomock.Any()).Return(context.TODO(), trsp).AnyTimes()
	return reconciler
}
