package utils

/*
Copyright 2022 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"fmt"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/require"

	"github.com/gruntwork-io/terratest/modules/helm"
	"github.com/gruntwork-io/terratest/modules/k8s"
	"github.com/gruntwork-io/terratest/modules/random"
	"github.com/gruntwork-io/terratest/modules/shell"
	corev1 "k8s.io/api/core/v1"
	networkingv1 "k8s.io/api/networking/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type Workflow struct {
	cluster       string
	port          int
	error         error
	namespace     string
	k8gbNamespace string
	k8gbCoreDNSIP string
	k8sOptions    *k8s.KubectlOptions
	t             *testing.T
	isRunning     bool
	ingress       struct {
		path     string
		name     string
		instance *networkingv1.Ingress
	}
	testApp struct {
		name        string
		message     string
		isRunning   bool
		isInstalled bool
	}
	busybox struct {
		isInstalled bool
		isRunning   bool
	}
}

type Instance struct {
	w *Workflow
}

const defaultRetries = 10
const defaultSeconds = 10

func NewWorkflow(t *testing.T, cluster string, port int) *Workflow {
	var err error
	if cluster == "" {
		err = fmt.Errorf("empty cluster")
	}
	if port < 1000 {
		err = fmt.Errorf("invalid port")
	}
	w := new(Workflow)
	w.cluster = cluster
	w.namespace = fmt.Sprintf("k8gb-test-%s", strings.ToLower(random.UniqueId()))
	w.k8sOptions = k8s.NewKubectlOptions(cluster, "", w.namespace)
	w.t = t
	w.port = port
	w.error = err
	w.k8gbNamespace = "k8gb"
	return w
}

func (w *Workflow) WithIngress(path string) *Workflow {
	if path == "" {
		w.error = fmt.Errorf("empty ingress resource path")
	}
	w.ingress.path = path
	w.ingress.name, w.error = w.getManifestName(path)
	return w
}

func (w *Workflow) WithTestApp(uiMessage string) *Workflow {
	w.testApp.isInstalled = true
	w.testApp.name = "frontend-podinfo"
	w.testApp.message = uiMessage
	return w
}

func (w *Workflow) WithBusybox() *Workflow {
	w.busybox.isInstalled = true
	return w
}

func (w *Workflow) Start() (*Instance, error) {
	if w.error != nil {
		return nil, w.error
	}
	// CoreDNS IP
	w.t.Log("Getting K8gb CoreDNSIP")
	w.k8gbCoreDNSIP = w.getCoreDNSIP()

	// namespace
	w.t.Logf("Create namespace %s", w.namespace)
	k8s.CreateNamespace(w.t, w.k8sOptions, w.namespace)

	// app
	if w.testApp.isInstalled {
		const app = "https://stefanprodan.github.io/podinfo"
		w.t.Logf("Create test application %s", app)
		helmRepoAdd := shell.Command{
			Command: "helm",
			Args:    []string{"repo", "add", "--force-update", "podinfo", app},
		}
		helmRepoUpdate := shell.Command{
			Command: "helm",
			Args:    []string{"repo", "update"},
		}
		shell.RunCommand(w.t, helmRepoAdd)
		shell.RunCommand(w.t, helmRepoUpdate)
		helmOptions := helm.Options{
			KubectlOptions: w.k8sOptions,
			Version:        "5.2.0",
			SetValues:      map[string]string{"ui.message": w.testApp.message},
		}
		helm.Install(w.t, &helmOptions, "podinfo/podinfo", "frontend")
		testAppFilter := metav1.ListOptions{
			LabelSelector: "app.kubernetes.io/name=" + w.testApp.name,
		}
		k8s.WaitUntilNumPodsCreated(w.t, w.k8sOptions, testAppFilter, 1, defaultRetries, defaultSeconds*time.Second)
		var testAppPods []corev1.Pod
		testAppPods = k8s.ListPods(w.t, w.k8sOptions, testAppFilter)
		for _, pod := range testAppPods {
			k8s.WaitUntilPodAvailable(w.t, w.k8sOptions, pod.Name, defaultRetries, defaultSeconds*time.Second)
		}
		k8s.WaitUntilServiceAvailable(w.t, w.k8sOptions, w.testApp.name, defaultRetries, defaultSeconds*time.Second)
		w.testApp.isRunning = true
	}

	// busybox
	if w.busybox.isInstalled {
		w.t.Log("Installing busybox")
		command := fmt.Sprintf(`echo 'nameserver %s' > /etc/resolv.conf && sleep 1000`, w.k8gbCoreDNSIP)
		kubectlRunBusybox := shell.Command{
			Command: "kubectl",
			Args: []string{"--context", w.k8sOptions.ContextName, "-n", w.k8sOptions.Namespace, "run", "busybox",
				"--image=busybox", "--", "sh", "-c", command},
		}
		shell.RunCommand(w.t, kubectlRunBusybox)
		w.busybox.isRunning = true
	}

	// ingress
	if w.ingress.path != "" {
		w.t.Logf("Create ingress from %s", w.ingress.path)
		k8s.KubectlApply(w.t, w.k8sOptions, w.ingress.path)
		k8s.WaitUntilIngressAvailable(w.t, w.k8sOptions, w.ingress.name, defaultRetries, defaultSeconds*time.Second)
		w.ingress.instance = k8s.GetIngress(w.t, w.k8sOptions, w.ingress.name)
	}
	w.isRunning = true
	return &Instance{
		w: w,
	}, nil
}

// GetCoreDNSIP gets core DNS IP address
func (w *Workflow) getCoreDNSIP() string {
	cmd := shell.Command{
		Command: "kubectl",
		Args:    []string{"--context", w.k8sOptions.ContextName, "-n", "k8gb", "get", "svc", "k8gb-coredns", "--no-headers", "-o", "custom-columns=IP:spec.clusterIPs[0]"},
		Env:     w.k8sOptions.Env,
	}
	out, err := shell.RunCommandAndGetOutputE(w.t, cmd)
	require.NoError(w.t, err)
	require.NotEqual(w.t, "<none>", out)
	return out
}

func (i *Instance) getAppStatus() string {
	if !i.w.testApp.isRunning {
		return ""
	}
	cmd := shell.Command{
		Command: "kubectl",
		Args: []string{"--context", i.w.k8sOptions.ContextName, "-n", i.w.k8sOptions.Namespace, "get", "pod", "-l",
			"app.kubernetes.io/name=frontend-podinfo", "--no-headers", "-o", "custom-columns=STATUS:.status.phase"},
	}
	out, err := shell.RunCommandAndGetOutputE(i.w.t, cmd)
	require.NoError(i.w.t, err)
	return out
}
